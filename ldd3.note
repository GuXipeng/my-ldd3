ch6. 高级字符驱动操作
  6.1 ioctl接口
    user space: int ioctl(int fd, unsigned long cmd, ...);
    kernel space: int (*ioctl) (struct inode *inode, struct file *filp, unsigned int cmd, unsigned long arg);
    inode 和 filp 指针是对应应用程序传递的文件描述符 fd 的值, 和传递给 open 方法的相同参数.
    6.1.1 选择ioctl命令
      根据 Linux 内核惯例来为你的驱动选择 ioctl 号, 你应当首先检查 include/asm/ioctl.h 和
    Documentation/ioctl-number.txt. 这个头文件定义你将使用的位段: type(魔数), 序号, 传输方向, 和参数大小. ioctl-number.txt 文件列举了在内核中使用的魔数,[20] 因此你将可选择你自己的魔数并且避免交叠. 这个文本文件也列举了为什么应当使用惯例的原因.
      ioctl 命令号　４个位段
      type

      number

      direction

      size
    ** 地址校验，<asm/uaccess.h> access_ok():
      (API) int access_ok(int type, const void *addr, unsigned long size) first para is VERIFY_READ or VERIFY_WRITE 在需要读写操作 VERIFY_WRITE.
      return value: 1 success, 0 failed 驱动则返回-EFAULT给调用者。
    (API) put_user(datum, ptr) 写datum到用户空间
    __put_user(datum, ptr) 此接口用在已经进行access_ok检查过的时候
    作为一个通用的规则, 当你实现一个 read 方法时, 调用 __put_user 来节省几个周期, 或者当你拷贝几个项时, 因此, 在第一次数据传送之前调用 access_ok 一次。
    (API) get_user(local, ptr) 从用户空间接收单个数据
    __get_user(local, ptr)
    6.1.5 能力和受限操作
      (API) capget or capset系统调用使用能力
      全部能力可在 <linux/capability.h> 中找到. 如下面所示：
      CAP_DAC_OVERRIDE
      这个能力来推翻在文件和目录上的存取的限制(数据存取控制, 或者 DAC).

      CAP_NET_ADMIN
      进行网络管理任务的能力, 包括那些能够影响网络接口的.

      CAP_SYS_MODULE
      加载或去除内核模块的能力.

      CAP_SYS_RAWIO
      进行 "raw" I/O 操作的能力. 例子包括存取设备端口或者直接和 USB 设备通讯.

      CAP_SYS_ADMIN
      一个捕获-全部的能力, 提供对许多系统管理操作的存取.

      CAP_SYS_TTY_CONFIG
      进行 tty 配置任务的能力.
      能力检查是通过 capable 函数来进行的(定义在 <linux/sched.h>):
      (API)  int capable(int capability);
      在 scull 例子驱动中, 任何用户被许可来查询 quantum 和 quantum 集的大小. 只有特权用户, 但是, 可改变这些值, 因为不适当的值可能很坏地影响系统性能. 当需要时, ioctl 的 scull 实现检查用户的特权级别, 如下:
        if (! capable (CAP_SYS_ADMIN))
          return -EPERM;
    6.1.6. ioctl 命令的实现

